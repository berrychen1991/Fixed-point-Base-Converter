<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>二進位計算機（Q 格式）— 截斷模式</title>
  <style>
    :root{--bg:#0b0f14;--panel:#111827;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--danger:#f87171;--ok:#34d399;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}html,body{height:100%}body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",Arial}
    .app{max-width:1100px;margin:24px auto 80px;padding:0 16px}
    h1{font-size:22px;margin:0 0 8px}.desc{color:var(--muted);margin-bottom:12px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:14px}
    .grid{display:grid;gap:12px}@media(min-width:900px){.grid-2{grid-template-columns:1fr 1fr}.grid-3{grid-template-columns:1fr 1fr 1fr}}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;align-items:center;justify-content:space-between;gap:6px}
    input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0d1320;color:#e5e7eb;outline:none}
    .copy-btn{border-radius:50%;border:1px solid var(--border);background:#0d1320;color:#e5e7eb;outline:none;cursor:pointer;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0}
    .copy-btn:hover{background:#0f1730}
    .out{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;word-break:break-all;white-space:pre-wrap;padding:8px 10px;border-radius:8px;background:#0b1220;border:1px solid var(--border)}
    .small{font-size:12px;color:var(--muted)}.ok{color:var(--ok);font-size:13px}.err{color:var(--danger);font-size:13px}
    .toast{position:fixed;right:16px;bottom:16px;background:#1f2937;color:#fff;padding:8px 12px;border-radius:8px;opacity:.95;white-space:pre-line}
    .row{display:flex;gap:8px;align-items:center}
    .hint{font-size:11px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="app">
    <h1>二進位計算機（Q 格式）</h1>
    <div class="desc">目前 <b>捨入模式：直接捨去（Truncate / Toward 0）</b>。輸入數值 → 設定 Qm.n 與進位/正負 → 顯示 Binary/Decimal/Hex/二補數。</div>

    <div class="panel grid grid-3">
      <div>
        <div class="label">輸入數值</div>
        <input id="in-value" placeholder="例如 -3.14159 或 101.01 或 FF.A / 0xFF.A / 0b101.11" value="-3.14159" />
        <div class="small">支援 2/10/16 進位；小數會<b>直接捨去</b>到 2^-n。</div>
      </div>
      <div>
        <div class="label">輸入進位</div>
        <div class="row">
          <select id="in-base">
            <option value="2">二進位</option>
            <option value="10" selected>十進位</option>
            <option value="16">十六進位</option>
          </select>
        </div>
        <div class="hint">＊<b>自動判斷位元圖樣</b>：
          <br>‣ 在二/十六進位時，若輸入 <u>沒有正負號、也沒有小數點</u>，視為「<b>位元圖樣</b>」，以 <b>m 位整數區</b>對齊（高位補 0），末尾補上 <b>n 個 0</b> 對齊小數區，最後以 N=m+n 位兩補數解讀。
          <br>‣ 在<b>二進位且包含小數點</b>時，若輸入只含 0/1 與一個小數點，亦視為<b>位元圖樣（含二進位小數點）</b>：會將整數區補到 m 位、小數區補到 n 位。例如：m=4,n=4，輸入 <code>1001.1</code> → <code>1001.1000</code>。
          <br>‣ 若包含正負號，則視為一般數值字面量解析。
        </div>
      </div>
      <div>
        <div class="label">Signed / Unsigned</div>
        <select id="in-signed">
          <option value="true" selected>Signed</option>
          <option value="false">Unsigned</option>
        </select>
      </div>
      <div>
        <div class="label">m 是否含符號位</div>
        <select id="m-includes-sign">
          <option value="true" selected>是</option>
          <option value="false">否</option>
        </select>
      </div>
      <div>
        <div class="label">整數位 m</div>
        <input id="in-m" type="number" min="1" max="60" value="4" />
      </div>
      <div>
        <div class="label">小數位 n</div>
        <input id="in-n" type="number" min="0" max="60" value="4" />
      </div>
      <div>
        <div class="label">顯示小數精度</div>
        <input id="in-prec" type="number" min="0" max="18" value="6" />
      </div>
    </div>

    <div class="panel grid grid-2">
      <div>
        <div class="label" id="lbl-bin"><span>Binary</span> <button class="copy-btn" data-copy="#out-bin" title="複製 Binary">⧉</button></div>
        <div class="out" id="out-bin">-</div>
      </div>
      <div>
        <div class="label"><span>Decimal</span> <button class="copy-btn" data-copy="#out-dec" title="複製 Decimal">⧉</button></div>
        <div class="out" id="out-dec">-</div>
        <div class="small">顯示小數位：<span id="out-prec">6</span></div>
      </div>
      <div>
        <div class="label"><span>Hex</span> <button class="copy-btn" data-copy="#out-hex" title="複製 Hex">⧉</button></div>
        <div class="out" id="out-hex">-</div>
      </div>
      <div>
        <div class="label"><span>Two's complement（~x+1）</span> <button class="copy-btn" data-copy="#out-twos" title="複製 Two's complement">⧉</button></div>
        <div class="out" id="out-twos">-</div>
      </div>
    </div>

    <div class="panel">
      <div id="out-status" class="ok">輸入有效，範圍內。</div>
      <div class="small" style="margin-top:8px; white-space:pre-line" id="out-range"></div>
    </div>
  </div>

  <script>
    // ===== Copy helpers =====
    function showToast(msg){const t=document.createElement('div');t.className='toast';t.textContent=msg;document.body.appendChild(t);setTimeout(function(){t.remove();},1200)}
    async function copySelector(sel){const el=document.querySelector(sel);if(!el){showToast('找不到輸出');return}const txt=el.textContent||'';try{await navigator.clipboard.writeText(txt);showToast('已複製')}catch(e){const ta=document.createElement('textarea');ta.value=txt;document.body.appendChild(ta);ta.select();try{document.execCommand('copy');showToast('已複製')}finally{document.body.removeChild(ta)}}}
    document.addEventListener('click',function(e){const btn=e.target.closest('[data-copy]');if(btn){copySelector(btn.getAttribute('data-copy'))}})

    // ===== Utilities (ASCII-only, BigInt-safe) =====
    function clamp(x,lo,hi){return (x<lo?lo:(x>hi?hi:x));}
    function rmall(s,needle){const esc=needle.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');return s.replace(new RegExp(esc,'g'),'')}
    function bigintToBinary(n,width){const W=BigInt(width);const mask=(1n<<W)-1n;return(n&mask).toString(2).padStart(Number(W),'0')}
    function parseFractionalInBase(fracStr,base){if(!fracStr)return{num:0n,den:1n};const k=fracStr.length;const den=BigInt(base)**BigInt(k);let num=0n;for(let i=0;i<k;i++){const v=parseInt(fracStr[i],base);if(!Number.isFinite(v)||v<0||v>=base)return null;num=num*BigInt(base)+BigInt(v)}return{num:num,den:den}}
    function parseSignedDecimal(str){const s=rmall(str.trim(),'_');if(!s)return null;let sign=1n;let t=s;if(t[0]==='+')t=t.slice(1);else if(t[0]==='-'){sign=-1n;t=t.slice(1)}let intPart=0n,i=0;while(i<t.length&&t[i]!=='.'){const code=t.charCodeAt(i)-48;if(code<0||code>9)return null;intPart=intPart*10n+BigInt(code);i++}let num=0n,den=1n;if(i<t.length&&t[i]==='.'){{const f=parseFractionalInBase(t.slice(i+1),10);if(!f)return null;num=f.num;den=f.den}}return{sign:sign,intPart:intPart,num:num,den:den}}

    // 允許 0x/0X 與 0b/0B 前綴；忽略空白；支援 base=2/16 的小數
    function parseBaseInput(valueStr,base){
      let s=rmall(valueStr.trim(),'_');
      s=s.replace(/\s+/g,'');
      let sign=1n;
      if(s.startsWith('-')){sign=-1n;s=s.slice(1)}
      else if(s.startsWith('+')){s=s.slice(1)}
      if(base===2&&(s.startsWith('0b')||s.startsWith('0B'))) s=s.slice(2);
      if(base===16&&(s.startsWith('0x')||s.startsWith('0X'))) s=s.slice(2);
      const parts=s.split('.');
      if(parts.length>2) return null;
      const ip=parts[0];
      const fp=(parts.length>1?parts[1]:'');
      let intVal=0n;
      for(let i=0;i<ip.length;i++){
        const v=parseInt(ip[i],base);
        if(!Number.isFinite(v)||v<0||v>=base) return null;
        intVal=intVal*BigInt(base)+BigInt(v);
      }
      const frac=parseFractionalInBase(fp,base); if(!frac) return null;
      return {sign:sign,intVal:intVal,frac:frac};
    }

    // 位元圖樣（整數區 m 位 + 末尾補 n 個 0）
    function parseAsBitPattern(valueStr, base, m, n, totalBits, signed){
      if(!(base===2||base===16)) return { err:'僅支援在二/十六進位下以位元圖樣輸入。' };
      let s=rmall(valueStr.trim(),'_');
      s=s.replace(/\s+/g,'');
      if(base===2&&(s.startsWith('0b')||s.startsWith('0B'))) s=s.slice(2);
      if(base===16&&(s.startsWith('0x')||s.startsWith('0X'))) s=s.slice(2);
      s=s.replace(/\./g,'');
      const re = base===2 ? /^[01]+$/i : /^[0-9a-f]+$/i;
      if(!re.test(s)) return { err:'位元圖樣包含非法字元。' };
      let valRaw = 0n;
      for(let i=0;i<s.length;i++){ valRaw = valRaw*BigInt(base) + BigInt(parseInt(s[i],base)); }
      const kbits = (base===2) ? s.length : 4*s.length;
      if(kbits>m) return { err:'位元圖樣（整數區）長度超過 m。' };
      const shiftToM = Math.max(0, m - kbits);
      let valM = valRaw << BigInt(shiftToM);
      let valN = valM << BigInt(n);
      const N = totalBits; const mask=(1n<<BigInt(N))-1n; valN &= mask;
      const topBit = (valN >> BigInt(N-1)) & 1n;
      const scaled = (signed && topBit===1n) ? (valN - (1n<<BigInt(N))) : valN;
      return { scaled: scaled, overflow:false };
    }

    // 位元圖樣（含二進位小數點）：整數區補到 m 位、小數區補到 n 位
    function parseAsBinaryPointPattern(valueStr, m, n, totalBits, signed, mIncludesSign){
      let s=rmall(valueStr.trim(),'_');
      s=s.replace(/\s+/g,'');
      if(s.startsWith('+')||s.startsWith('-')) return { err:'位元圖樣不接受正負號。' };
      if(s.startsWith('0b')||s.startsWith('0B')) s=s.slice(2);
      const parts = s.split('.');
      if(parts.length!==2) return { err:'內部錯誤：需要二進位小數點。' };
      const ip = parts[0], fp = parts[1];
      if(!/^([01]*)$/.test(ip) || !/^([01]*)$/.test(fp)) return { err:'位元圖樣包含非法字元。' };
      if(ip.length>m) return { err:'整數區位數超過 m。' };
      if(fp.length>n) return { err:'小數區位數超過 n。' };
      const ipPad = ip.padStart(m,'0');
      const fpPad = fp.padEnd(n,'0');
      const bitStrLower = ipPad + fpPad; // 長度 m+n
      let val = 0n;
      for(let i=0;i<bitStrLower.length;i++){
        val = (val<<1n) + (bitStrLower[i]==='1'?1n:0n);
      }
      const N = totalBits; // 若 signed 且 m 不含符號位，N=m+1+n，最高位（符號位）預設為 0
      const mask=(1n<<BigInt(N))-1n; val &= mask;
      const topBit = (val >> BigInt(N-1)) & 1n;
      const scaled = (signed && topBit===1n) ? (val - (1n<<BigInt(N))) : val;
      return { scaled: scaled, overflow:false };
    }

    // Core: parse input to scaled integer using TRUNCATION (toward zero)
    function parseInputToScaled(cfg){
      var valueStr=cfg.valueStr, base=cfg.base, signed=cfg.signed, m=cfg.m, n=cfg.n, mIncludesSign=cfg.mIncludesSign;
      const totalBits = signed ? (mIncludesSign ? (m + n) : (m + 1 + n)) : (m + n);
      if (totalBits <= 0 || m < 0 || n < 0) return { err: 'Invalid bit widths.' };

      // Auto-detect 位元圖樣：
      // 1) base=2/16 且「無正負號、無小數點」→ 整數區 m 位 + 末尾補 n 個 0
      // 2) base=2 且「無正負號、含一個小數點（僅 0/1）」→ 二進位小數點模式（整數補到 m、小數補到 n）
      {
        var raw0 = rmall(String(valueStr).trim(),'_').replace(/\s+/g,'');
        var hasSign0 = raw0.startsWith('+') || raw0.startsWith('-');
        var hasDot0 = raw0.indexOf('.')>=0;
        if (base===2 || base===16){
          var raw = raw0;
          if (hasSign0) raw = raw.slice(1);
          if (base===2 && (raw.startsWith('0b')||raw.startsWith('0B'))) raw = raw.slice(2);
          if (base===16 && (raw.startsWith('0x')||raw.startsWith('0X'))) raw = raw.slice(2);
          var reInt = base===2 ? /^[01]+$/i : /^[0-9a-f]+$/i;
          if(!hasSign0 && !hasDot0 && reInt.test(raw)){
            const r=parseAsBitPattern(valueStr, base, m, n, totalBits, signed);
            if(r.err) return { err:r.err };
            const N=totalBits; let min, max;
            if (signed) { min = -(1n << BigInt(N-1)); max = (1n << BigInt(N-1)) - 1n; }
            else { min = 0n; max = (1n << BigInt(N)) - 1n; }
            const overflow = (r.scaled < min || r.scaled > max);
            const scaled = overflow ? (r.scaled<min?min:max) : r.scaled;
            return { scaled: scaled, overflow: overflow, totalBits: N, min: min, max: max };
          }
          if(base===2 && !hasSign0 && hasDot0){
            var reBinPoint = /^([01]*)\.([01]*)$/;
            if(reBinPoint.test(raw0.replace(/^0[bB]/,''))){
              const r2 = parseAsBinaryPointPattern(valueStr, m, n, totalBits, signed, mIncludesSign);
              if(r2.err) return { err:r2.err };
              const N=totalBits; let min, max;
              if (signed) { min = -(1n << BigInt(N-1)); max = (1n << BigInt(N-1)) - 1n; }
              else { min = 0n; max = (1n << BigInt(N)) - 1n; }
              const overflow = (r2.scaled < min || r2.scaled > max);
              const scaled = overflow ? (r2.scaled<min?min:max) : r2.scaled;
              return { scaled: scaled, overflow: overflow, totalBits: N, min: min, max: max };
            }
          }
        }
      }

      let rationalNum=0n,rationalDen=1n,negative=false;
      if (base === 10){
        const p=parseSignedDecimal(valueStr);
        if (p === null) return { err: 'Invalid decimal input.' };
        negative=p.sign < 0n; rationalNum=p.intPart * p.den + p.num; rationalDen=p.den;
      } else {
        const p=parseBaseInput(valueStr,base);
        if (p === null) return { err: 'Invalid input for base '+base+'.' };
        negative=p.sign < 0n; rationalNum=p.intVal * p.frac.den + p.frac.num; rationalDen=p.frac.den;
      }

      // Truncate toward zero
      const scaledAbs=(rationalNum * (1n << BigInt(n))) / rationalDen;

      // Unsigned 不接受負數（除了 -0），直接報錯
      if (!signed && negative && scaledAbs !== 0n){
        return { err: 'Unsigned 模式不接受負數。請改為 Signed 或輸入非負數。' };
      }

      let scaled = negative ? -scaledAbs : scaledAbs;

      // Clamp to representable range
      const N = totalBits; let min, max;
      if (signed) { min = -(1n << BigInt(N-1)); max = (1n << BigInt(N-1)) - 1n; }
      else { min = 0n; max = (1n << BigInt(N)) - 1n; }
      const overflow = (scaled < min || scaled > max); if (overflow) scaled = (scaled < min ? min : max);
      return { scaled: scaled, overflow: overflow, totalBits: N, min: min, max: max };
    }

    function binaryWithPointFromScaled(scaled,totalBits,n,signed){const N=Number(totalBits),F=Number(n);const mask=(1n<<BigInt(N))-1n;let twos=scaled;if(signed&&scaled<0n)twos=(scaled+(1n<<BigInt(N)))&mask;const bits=bigintToBinary(twos,N);if(F<=0)return bits;const cut=Math.max(0,bits.length-F);return bits.slice(0,cut)+'.'+bits.slice(cut)}
    function hexFromScaled(scaled,totalBits,signed){const N=Number(totalBits);const mask=(1n<<BigInt(N))-1n;let twos=scaled;if(signed&&scaled<0n)twos=(scaled+(1n<<BigInt(N)))&mask;return twos.toString(16).toUpperCase().padStart(Math.ceil(N/4),'0')}
    function twosComplementPattern(scaled,totalBits,signed){
      const N=Number(totalBits);
      const W=BigInt(N);
      const mask=(1n<<W)-1n;
      // 取得目前值在 N 位下的位元圖樣（兩補數表達）
      let bitsVal = scaled;
      if(bitsVal<0n){ bitsVal = (1n<<W) + bitsVal; }
      bitsVal &= mask;
      // 計算補數：~x + 1（模 2^N）
      let comp = ((~bitsVal) + 1n) & mask;
      return bigintToBinary(comp,N);
    }
    function scaledToDecimalString(scaled,n,precision){
      const sign = scaled<0n?'-':'';
      const abs = scaled<0n?-scaled:scaled;
      const intPart = abs>>BigInt(n);
      const fracMask=(1n<<BigInt(n))-1n;
      const frac=abs&fracMask;
      if(n===0) return sign+intPart.toString();
      if(precision<=0){ return sign+intPart.toString(); }
      const tenPow = 10n**BigInt(precision);
      let fracDec = (frac*tenPow)>>BigInt(n);
      let fracStr = fracDec.toString().padStart(precision,'0');
      fracStr = fracStr.replace(/0+$/,'');
      if(fracStr.length===0) return sign+intPart.toString();
      return sign+intPart.toString()+'.'+fracStr;
    }

    // ===== Wire UI =====
    const elValue=document.getElementById('in-value');
    const elBase=document.getElementById('in-base');
    const elSigned=document.getElementById('in-signed');
    const elMincl=document.getElementById('m-includes-sign');
    const elM=document.getElementById('in-m');
    const elN=document.getElementById('in-n');
    const elPrec=document.getElementById('in-prec');

    const outBin=document.getElementById('out-bin');
    const outDec=document.getElementById('out-dec');
    const outHex=document.getElementById('out-hex');
    const outTwos=document.getElementById('out-twos');
    const lblBin=document.getElementById('lbl-bin');
    const outPrec=document.getElementById('out-prec');
    const outStatus=document.getElementById('out-status');
    const outRange=document.getElementById('out-range');

    function state(){
      return {
        valueStr: elValue.value,
        base: parseInt(elBase.value,10),
        signed: elSigned.value==='true',
        mIncludesSign: elMincl.value==='true',
        m: clamp(parseInt(elM.value||'0',10),1,60),
        n: clamp(parseInt(elN.value||'0',10),0,60),
        precision: clamp(parseInt(elPrec.value||'0',10),0,18)
      };
    }

    function update(){
      const S=state();
      const N=S.signed ? (S.mIncludesSign ? (S.m+S.n) : (S.m+1+S.n)) : (S.m+S.n);
      const parsed=parseInputToScaled({ valueStr:S.valueStr, base:S.base, signed:S.signed, m:S.m, n:S.n, mIncludesSign:S.mIncludesSign });
      const err=parsed.err; const scaled=err?0n:parsed.scaled; const overflow=err?false:parsed.overflow;

      outPrec.textContent=String(S.precision);
      lblBin.innerHTML='<span>Binary（Q'+S.m+'.'+S.n+(S.signed?('，m'+(S.mIncludesSign?'含':'不含')+'符號位'):'')+'）</span> <button class="copy-btn" data-copy="#out-bin" title="複製 Binary">⧉</button>';

      if(err){
        outStatus.className='err'; outStatus.textContent='輸入錯誤：'+err;
        outBin.textContent=outDec.textContent=outHex.textContent=outTwos.textContent='-';
        outRange.textContent='';
        return;
      }

      outStatus.className=overflow?'err':'ok';
      outStatus.textContent=overflow?'已飽和到可表示範圍。':'輸入有效，範圍內。';

      outBin.textContent=binaryWithPointFromScaled(scaled,N,S.n,S.signed);
      outDec.textContent=scaledToDecimalString(scaled,S.n,S.precision);

      const hex=hexFromScaled(scaled,N,S.signed);
      outHex.textContent=(hex.match(/.{1,4}/g)||[hex]).join(' ');

      const twosBits=twosComplementPattern(scaled,N,S.signed);
      outTwos.textContent=(twosBits.match(/.{1,4}/g)||[twosBits]).join(' ');

      const min=S.signed?(-(1n<<BigInt(N-1))):0n;
      const max=S.signed?((1n<<BigInt(N-1))-1n):((1n<<BigInt(N))-1n);
      const line1='總位寬：'+N+' 位（'+(S.signed?((S.mIncludesSign?'m 含符號位':'m 不含符號位')+'，'):'')+'整數 '+S.m+' + 小數 '+S.n+'）。解析度：2^-'+S.n+'。Scaled 範圍：['+min.toString()+', '+max.toString()+']';
      const minReal=scaledToDecimalString(min,S.n,S.precision);
      const maxReal=scaledToDecimalString(max,S.n,S.precision);
      const line2='可表實數範圍：['+minReal+', '+maxReal+']';
      outRange.textContent=line1+'\n'+line2;
    }

    ;['input','change'].forEach(function(evt){
      var list=document.querySelectorAll('input,select');
      for(var i=0;i<list.length;i++){ list[i].addEventListener(evt,update); }
    });

    // First render
    update();

    // ===== Quick self-tests (console) =====
    (function selfTests(){
      var tests=[]; 
      function eq(name,a,b){ tests.push([Object.is(a,b),name,a,b]); }
      var r = parseInputToScaled({ valueStr:'1.99', base:10, signed:false, m:4, n:2, mIncludesSign:false });
      eq('pos trunc scaled', r.scaled, 7n);
      r = parseInputToScaled({ valueStr:'-1.99', base:10, signed:true, m:4, n:2, mIncludesSign:true });
      eq('neg trunc scaled', r.scaled, -7n);
      r = parseInputToScaled({ valueStr:'101.11', base:2, signed:false, m:6, n:2, mIncludesSign:false });
      eq('bin frac', r.scaled, 23n);
      r = parseInputToScaled({ valueStr:'0b101.11', base:2, signed:false, m:6, n:2, mIncludesSign:false });
      eq('bin frac with prefix', r.scaled, 23n);
      r = parseInputToScaled({ valueStr:'FF.A', base:16, signed:false, m:12, n:3, mIncludesSign:false });
      eq('hex frac', r.scaled, 2045n);
      r = parseInputToScaled({ valueStr:'0xFF.A', base:16, signed:false, m:12, n:3, mIncludesSign:false });
      eq('hex frac with prefix', r.scaled, 2045n);
      r = parseInputToScaled({ valueStr:'-9', base:10, signed:true, m:4, n:0, mIncludesSign:true });
      eq('signed clamp', r.scaled, -8n);
      // auto as-bits：整數區對齊後補 n 個 0
      r = parseInputToScaled({ valueStr:'1001', base:2, signed:true, m:4, n:0, mIncludesSign:true });
      eq("auto bits: '1001' (N=4, signed) -> -7", r.scaled, -7n);
      r = parseInputToScaled({ valueStr:'F', base:16, signed:true, m:4, n:0, mIncludesSign:true });
      eq("auto bits: 'F' (N=4, signed) -> -1", r.scaled, -1n);
      r = parseInputToScaled({ valueStr:'1001', base:2, signed:true, m:4, n:4, mIncludesSign:true });
      eq("auto bits: '1001' (N=8, signed, m=4,n=4) -> scaled -112", r.scaled, -112n);
      r = parseInputToScaled({ valueStr:'0111', base:2, signed:true, m:4, n:4, mIncludesSign:true });
      eq("auto bits: '0111' (N=8, signed) -> scaled +112", r.scaled, 112n);
      r = parseInputToScaled({ valueStr:'9', base:16, signed:true, m:4, n:4, mIncludesSign:true });
      eq("auto bits: '9' (N=8, signed) -> scaled -112", r.scaled, -112n);
      // auto binary-point bits：整數補到 m、小數補到 n
      var r2 = parseInputToScaled({ valueStr:'1001.1', base:2, signed:true, m:4, n:4, mIncludesSign:true });
      eq("auto bin-point: scaled -104", r2.scaled, -104n);
      eq("bin print for '1001.1' (Q4.4) -> 1001.1000", binaryWithPointFromScaled(r2.scaled, 8, 4, true), '1001.1000');
      eq("decimal print for '1001.1' (Q4.4) -> -6.5", scaledToDecimalString(r2.scaled, 4, 6), '-6.5');
      // two's complement correctness
      var rNeg112 = parseInputToScaled({ valueStr:'1001', base:2, signed:true, m:4, n:4, mIncludesSign:true });
      eq("twos(~x+1) of -112 -> 01110000", twosComplementPattern(rNeg112.scaled, 8, true), '01110000');
      var rPos112 = parseInputToScaled({ valueStr:'0111', base:2, signed:true, m:4, n:4, mIncludesSign:true });
      eq("twos(~x+1) of +112 -> 10010000", twosComplementPattern(rPos112.scaled, 8, true), '10010000');
      var rZero = parseInputToScaled({ valueStr:'0', base:10, signed:true, m:4, n:4, mIncludesSign:true });
      eq("twos(~x+1) of 0 -> 00000000", twosComplementPattern(rZero.scaled, 8, true), '00000000');
      var rMin = parseInputToScaled({ valueStr:'-8', base:10, signed:true, m:4, n:4, mIncludesSign:true });
      eq("twos(~x+1) of min -> 10000000", twosComplementPattern(rMin.scaled, 8, true), '10000000');
      // update should not throw
      try { update(); eq('update runs', true, true); } catch(e){ eq('update runs', true, false); }

      var pass = tests.filter(function(t){return t[0];}).length; 
      var fail = tests.filter(function(t){return !t[0];});
      console.group('[SelfTests]');
      console.log('Passed: '+pass+'/'+tests.length);
      for(var i=0;i<fail.length;i++){ var t=fail[i]; console.warn('FAIL:', t[1], 'got:', t[2], 'expected:', t[3]); }
      console.groupEnd();
    })();
  </script>
</body>
</html>
