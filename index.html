<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>二進位計算機（Q 格式＋位元畫布）</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#111827;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;
      --danger:#f87171;--ok:#34d399;--sign:#f59e0b;--int:#10b981;--frac:#8b5cf6;
      --bitbox:#0b1220;--border:rgba(255,255,255,.08)
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 20% -10%,#0d1622 0%,var(--bg) 50%,#070a0f 100%);
      color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",Arial}
    .app{max-width:1100px;margin:24px auto 80px;padding:0 16px}
    h1{font-size:22px;margin:0 0 10px}.desc{color:var(--muted);margin-bottom:16px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));
      border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:14px;backdrop-filter:blur(2px)}
    .grid{display:grid;gap:12px}
    @media(min-width:900px){.grid-2{grid-template-columns:1fr 1fr}.grid-3{grid-template-columns:1fr 1fr 1fr}}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:#0d1320;color:var(--text);outline:none}
    .out{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;word-break:break-all;white-space:pre-wrap;
      padding:8px 10px;border-radius:8px;background:var(--bitbox);border:1px solid var(--border)}
    .small{font-size:12px;color:var(--muted)}.ok{color:var(--ok);font-size:13px}.err{color:var(--danger);font-size:13px}
    .canvasWrap{overflow-x:auto;padding-bottom:8px}.canvasBox{background:var(--bitbox);border:1px solid var(--border);border-radius:10px;padding:8px}
  </style>
</head>
<body>
  <div class="app">
    <h1>二進位計算機（Q 格式 + 位元畫布）</h1>
    <div class="desc">輸入數值 → 設定 Qm.n（m 不含符號位）與進位/正負 → 顯示 Binary/Decimal/Hex/二補數。可在畫布點位元切換。</div>

    <div class="panel grid grid-3">
      <div>
        <div class="label">輸入數值</div>
        <input id="in-value" placeholder="例如 -3.14159 或 101.01 或 FF.A" value="-3.14159">
        <div class="small">支援 2/10/16 進位（以下方選單指定）；小數四捨五入到 2^-n。</div>
      </div>
      <div>
        <div class="label">輸入進位</div>
        <select id="in-base">
          <option value="2">二進位 (bin)</option>
          <option value="10" selected>十進位 (dec)</option>
          <option value="16">十六進位 (hex)</option>
        </select>
      </div>
      <div>
        <div class="label">Signed / Unsigned</div>
        <select id="in-signed">
          <option value="true" selected>Signed（二補數）</option>
          <option value="false">Unsigned（無符號）</option>
        </select>
      </div>

      <div>
        <div class="label">整數位 m</div>
        <input id="in-m" type="number" min="0" max="60" value="3">
      </div>
      <div>
        <div class="label">小數位 n</div>
        <input id="in-n" type="number" min="0" max="60" value="5">
      </div>
      <div>
        <div class="label">顯示小數精度</div>
        <input id="in-prec" type="number" min="0" max="18" value="6">
      </div>
    </div>

    <div class="panel canvasBox">
      <div class="label">位元畫布（可左右捲動，點擊切換 0/1）</div>
      <div class="canvasWrap">
        <canvas id="bit-canvas" style="width:100%;height:140px;display:block"></canvas>
      </div>
    </div>

    <div class="panel grid grid-2">
      <div>
        <div class="label" id="lbl-bin">Binary</div>
        <div class="out" id="out-bin">-</div>
      </div>
      <div>
        <div class="label">Decimal（量化後值）</div>
        <div class="out" id="out-dec">-</div>
        <div class="small">顯示小數位：<span id="out-prec">6</span></div>
      </div>
      <div>
        <div class="label">Hex（位元圖樣，以 4 位群組）</div>
        <div class="out" id="out-hex">-</div>
        <div class="small">說明：此為定點位元圖樣的十六進位表示；小數位置由 Q 格式解讀。</div>
      </div>
      <div>
        <div class="label">Two's complement bit pattern</div>
        <div class="out" id="out-twos">-</div>
      </div>
    </div>

    <div class="panel">
      <div id="out-status" class="ok">輸入有效，範圍內。</div>
      <div class="small" style="margin-top:8px" id="out-range"></div>
    </div>
  </div>

  <script>
    // ---------- helpers (ASCII only) ----------
    const clamp = (x, lo, hi) => (x < lo ? lo : x > hi ? hi : x);
    const absBig = (a) => (a < 0n ? -a : a);
    function rmall(s, needle){ const esc = needle.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&"); return s.replace(new RegExp(esc, "g"), ""); }

    function bigintToBinary(n, width){
      const W = BigInt(width);
      const mask = (1n << W) - 1n;
      return (n & mask).toString(2).padStart(Number(W), "0");
    }

    function parseFractionalInBase(fracStr, base){
      if (!fracStr) return { num:0n, den:1n };
      const k = fracStr.length;
      const den = BigInt(base) ** BigInt(k);
      let num = 0n;
      for (let i=0; i<k; i++){
        const v = parseInt(fracStr[i], base);
        if (!Number.isFinite(v) || v < 0 || v >= base) return null;
        num = num * BigInt(base) + BigInt(v);
      }
      return { num, den };
    }

    function parseSignedDecimal(str){
      const s = rmall(str.trim(), "_");
      if (!s) return null;
      let sign = 1n;
      let t = s;
      if (t[0] === "+") t = t.slice(1);
      else if (t[0] === "-"){ sign = -1n; t = t.slice(1); }

      let intPart = 0n, i = 0;
      while (i < t.length && t[i] !== "."){
        const code = t.charCodeAt(i) - 48;
        if (code < 0 || code > 9) return null;
        intPart = intPart * 10n + BigInt(code);
        i++;
      }
      let num = 0n, den = 1n;
      if (i < t.length && t[i] === "."){
        const f = parseFractionalInBase(t.slice(i+1), 10);
        if (!f) return null;
        num = f.num; den = f.den;
      }
      return { sign, intPart, num, den };
    }

    // parse input to scaled (value * 2^n), clamp to range
    function parseInputToScaled({ valueStr, base, signed, intBits, fracBits }){
      const N = (signed ? 1 : 0) + intBits + fracBits;
      if (N <= 0 || intBits < 0 || fracBits < 0) return { err:"Invalid bit widths." };
      const scale = 1n << BigInt(fracBits);

      let rationalNum = 0n, rationalDen = 1n, negative = false;

      if (base === 10){
        const p = parseSignedDecimal(valueStr);
        if (p === null) return { err:"Invalid decimal input." };
        negative = p.sign < 0n;
        rationalNum = p.intPart * p.den + p.num;
        rationalDen = p.den;
      } else {
        let s = rmall(valueStr.trim(), "_");
        let sg = 1;
        if (s.startsWith("-")){ sg = -1; s = s.slice(1); }
        else if (s.startsWith("+")){ s = s.slice(1); }
        const parts = s.split(".");
        if (parts.length > 2) return { err:"Too many decimal points." };
        const [ip, fp=""] = parts;

        let intVal = 0n;
        for (let i=0; i<ip.length; i++){
          const v = parseInt(ip[i], base);
          if (!Number.isFinite(v) || v < 0 || v >= base) return { err:"Invalid digit for base." };
          intVal = intVal * BigInt(base) + BigInt(v);
        }
        const frac = parseFractionalInBase(fp, base);
        if (!frac) return { err:"Invalid fractional digits." };

        negative = sg < 0;
        rationalNum = intVal * frac.den + frac.num;
        rationalDen = frac.den;
      }

      // scaledAbs = round((num/den) * 2^fracBits), half-up
      const scaledAbsTimesDen = rationalNum * (1n << BigInt(fracBits));
      let scaledAbs = scaledAbsTimesDen / rationalDen;
      const rem = scaledAbsTimesDen % rationalDen;
      if (rem * 2n >= rationalDen) scaledAbs += 1n;
      let scaled = negative ? -scaledAbs : scaledAbs;

      let min, max;
      if (signed){ min = -(1n << BigInt(N-1)); max = (1n << BigInt(N-1)) - 1n; }
      else { min = 0n; max = (1n << BigInt(N)) - 1n; }
      const overflow = scaled < min || scaled > max;
      if (overflow) scaled = scaled < min ? min : max;

      return { scaled, overflow };
    }

    function binaryWithPointFromScaled(scaled, totalBits, fracBits, signed){
      const N = Number(totalBits), F = Number(fracBits);
      const mask = (1n << BigInt(N)) - 1n;
      let twos = scaled;
      if (signed && scaled < 0n) twos = (scaled + (1n << BigInt(N))) & mask;
      const bits = bigintToBinary(twos, N);
      if (F <= 0) return bits;
      const cut = Math.max(0, bits.length - F);
      return bits.slice(0, cut) + "." + bits.slice(cut);
    }

    function hexFromScaled(scaled, totalBits, signed){
      const N = Number(totalBits);
      const mask = (1n << BigInt(N)) - 1n;
      let twos = scaled;
      if (signed && scaled < 0n) twos = (scaled + (1n << BigInt(N))) & mask;
      return twos.toString(16).toUpperCase().padStart(Math.ceil(N/4), "0");
    }

    function scaledToDecimalString(scaled, fracBits, precision){
      const sign = scaled < 0n ? "-" : "";
      const abs = absBig(scaled);
      const intPart = abs >> BigInt(fracBits);
      const fracMask = (1n << BigInt(fracBits)) - 1n;
      const frac = abs & fracMask;
      if (precision <= 0 || fracBits === 0) return sign + intPart.toString();

      const tenPow = 10n ** BigInt(precision);
      const fracDec = (frac * tenPow + (1n << BigInt(fracBits-1))) >> BigInt(fracBits);
      return sign + intPart.toString() + "." + fracDec.toString().padStart(precision, "0");
    }

    // ---------- UI state ----------
    const elValue = document.getElementById("in-value");
    const elBase  = document.getElementById("in-base");
    const elSigned= document.getElementById("in-signed");
    const elM     = document.getElementById("in-m");
    const elN     = document.getElementById("in-n");
    const elPrec  = document.getElementById("in-prec");

    const outBin  = document.getElementById("out-bin");
    const outDec  = document.getElementById("out-dec");
    const outHex  = document.getElementById("out-hex");
    const outTwos = document.getElementById("out-twos");
    const lblBin  = document.getElementById("lbl-bin");
    const outPrec = document.getElementById("out-prec");
    const outStatus = document.getElementById("out-status");
    const outRange  = document.getElementById("out-range");

    const canvas = document.getElementById("bit-canvas");
    let hoverIndex = null;

    function currentState(){
      return {
        valueStr: elValue.value,
        base: parseInt(elBase.value, 10),
        signed: elSigned.value === "true",
        m: clamp(parseInt(elM.value||"0",10), 0, 60),
        n: clamp(parseInt(elN.value||"0",10), 0, 60),
        precision: clamp(parseInt(elPrec.value||"0",10), 0, 18)
      };
    }

    function updateUI(){
      const { valueStr, base, signed, m, n, precision } = currentState();
      const totalBits = (signed ? 1 : 0) + m + n;

      const parsed = parseInputToScaled({ valueStr, base, signed, intBits: m, fracBits: n });
      const err = parsed.err;
      const scaled = err ? 0n : parsed.scaled;
      const overflow = err ? false : parsed.overflow;

      outPrec.textContent = String(precision);
      lblBin.textContent = `Binary（Q${m}.${n}）`;

      if (err){
        outStatus.className = "err";
        outStatus.textContent = "輸入錯誤：" + err;
        outBin.textContent = "-";
        outDec.textContent = "-";
        outHex.textContent = "-";
        outTwos.textContent = "-";
        outRange.textContent = "";
      } else {
        outStatus.className = overflow ? "err" : "ok";
        outStatus.textContent = overflow ? "已飽和到可表示範圍。" : "輸入有效，範圍內。";

        outBin.textContent = binaryWithPointFromScaled(scaled, totalBits, n, signed);
        outDec.textContent = scaledToDecimalString(scaled, n, precision);

        const hex = hexFromScaled(scaled, totalBits, signed);
        outHex.textContent = (hex.match(/.{1,4}/g) || [hex]).join(" ");

        const mask = (1n << BigInt(totalBits)) - 1n;
        let v = scaled;
        if (signed && v < 0n) v = (v + (1n << BigInt(totalBits))) & mask;
        const plain = bigintToBinary(v, totalBits);
        outTwos.textContent = (plain.match(/.{1,4}/g) || [plain]).join(" ");

        const min = signed ? (-(1n << BigInt(totalBits-1))) : 0n;
        const max = signed ? ((1n << BigInt(totalBits-1)) - 1n) : ((1n << BigInt(totalBits)) - 1n);
        outRange.textContent = `總位寬：${totalBits} 位（${signed ? "含符號位 1 + " : ""}整數 ${m} + 小數 ${n}）。解析度：2^-` + n + `。Scaled 範圍：[${min.toString()}, ${max.toString()}]`;
      }

      drawCanvas(totalBits, n, signed, err ? 0n : scaled);
    }

    function drawCanvas(N, fracBits, signed, scaled){
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.floor(w*dpr);
      canvas.height= Math.floor(h*dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);

      ctx.clearRect(0,0,w,h);
      const padding = 12, top = 42, boxH = 44, gap = 6;
      const maxBoxW = Math.max(22, Math.min(48, (w - padding*2)/N - 4));
      const left = padding;

      const mask = (1n << BigInt(N)) - 1n;
      let twos = scaled;
      if (signed && scaled < 0n) twos = (scaled + (1n << BigInt(N))) & mask;
      const bitstr = bigintToBinary(twos, N);

      ctx.font = "14px sans-serif"; ctx.fillStyle = "#9ca3af";
      ctx.fillText("Click a box to toggle the bit", padding, 16);
      ctx.fillText(`Total ${N} bits | signed: ${signed ? "two's complement" : "unsigned"} | frac bits: ${fracBits}`, padding, 30);

      for (let i=0;i<N;i++){
        const x = left + i * (maxBoxW + gap);
        const y = top;
        const isSign = signed && i===0;
        const isFrac = i >= N - fracBits;
        const isHover = hoverIndex === i;

        ctx.beginPath(); ctx.rect(x,y,maxBoxW,boxH);
        ctx.fillStyle = isHover ? "#e5e7eb" : isSign ? "#f59e0b33" : isFrac ? "#8b5cf633" : "#60a5fa22";
        ctx.fill(); ctx.strokeStyle="#9ca3af"; ctx.stroke();

        const bit = bitstr[i];
        ctx.fillStyle = "#e5e7eb"; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.font="bold 16px ui-monospace, SFMono-Regular, Menlo, monospace";
        ctx.fillText(bit, x + maxBoxW/2, y + boxH/2);

        ctx.font = "10px ui-monospace, monospace"; ctx.fillStyle = "#9ca3af";
        ctx.fillText(String(i), x + maxBoxW/2, y + boxH + 10);

        if (i === N - fracBits - 1 && fracBits > 0){
          ctx.beginPath(); ctx.moveTo(x + maxBoxW + gap/2, y); ctx.lineTo(x + maxBoxW + gap/2, y + boxH);
          ctx.setLineDash([4,4]); ctx.strokeStyle="#60a5fa"; ctx.stroke(); ctx.setLineDash([]);
        }
      }

      // events
      canvas.onmousemove = (e)=>{
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if (my < top || my > top + boxH){ hoverIndex = null; updateUIThrottle(); return; }
        const stride = maxBoxW + gap;
        let idx = Math.floor((mx - left) / stride);
        const x0 = left + idx * stride;
        if (idx < 0 || idx >= N || mx < x0 || mx > x0 + maxBoxW){ hoverIndex = null; updateUIThrottle(); return; }
        hoverIndex = idx; updateUIThrottle();
      };
      canvas.onmouseleave = ()=>{ hoverIndex = null; updateUIThrottle(); };
      canvas.onclick = (e)=>{
        const state = currentState();
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if (my < top || my > top + boxH) return;
        const stride = Math.max(22, Math.min(48, (w - padding*2)/N - 4)) + gap;
        let idx = Math.floor((mx - left) / stride);
        const x0 = left + idx * (stride);
        if (idx < 0 || idx >= N || mx < x0 || mx > x0 + (stride-gap)) return;

        // toggle bit at idx (0 = MSB)
        const mask = (1n << BigInt(N)) - 1n;
        let twos = parseInputToScaled({ valueStr: state.valueStr, base: state.base, signed: state.signed, intBits: state.m, fracBits: state.n }).scaled;
        if (state.signed && twos < 0n) twos = (twos + (1n << BigInt(N))) & mask;
        const bitMask = 1n << BigInt(N - 1 - idx);
        let twosNew = (twos ^ bitMask) & mask;
        let scaledNew = (state.signed && (twosNew & (1n << BigInt(N-1)))) ? (twosNew - (1n << BigInt(N))) : twosNew;

        const newDec = scaledToDecimalString(scaledNew, state.n, Math.max(12, state.precision));
        elValue.value = newDec;
        updateUI();
      };
    }

    // simple throttle for hover redraws
    let rafId = null;
    function updateUIThrottle(){ if (rafId) cancelAnimationFrame(rafId); rafId = requestAnimationFrame(()=>{ updateUI(); rafId=null; }); }

    // wire inputs
    ["input","change"].forEach(evt=>{
      elValue.addEventListener(evt, updateUI);
      elBase.addEventListener(evt, updateUI);
      elSigned.addEventListener(evt, updateUI);
      elM.addEventListener(evt, updateUI);
      elN.addEventListener(evt, updateUI);
      elPrec.addEventListener(evt, updateUI);
    });

    // initial render + self tests
    updateUI();
    runSelfTests();

    // ---------- self tests (console) ----------
    function runSelfTests(){
      const tests = [];
      const eq = (name, a, b)=>{ tests.push([Object.is(a,b), name, a, b]); };

      // BigInt padding
      eq("bigintToBinary pad 8", bigintToBinary(5n,8), "00000101");

      // two's of -1, 8 bits
      const N = 8;
      const s2 = bigintToBinary( ((-1n + (1n<<BigInt(N))) & ((1n<<BigInt(N))-1n)), N );
      eq("two's -1 (8b)", s2, "11111111");

      // Q1.3 signed: -0.75 -> scaled -6 (since 0.75 * 2^3 = 6), bin "1.010" int.frac but our printer shows full N bits with point at n=3
      const p = parseInputToScaled({ valueStr:"-0.75", base:10, signed:true, intBits:1, fracBits:3 });
      eq("Q1.3 scaled", p.scaled, -6n);

      // fracBits=0 edge
      const p2 = parseInputToScaled({ valueStr:"5", base:10, signed:false, intBits:4, fracBits:0 });
      eq("fracBits=0", p2.scaled, 5n);
      eq("fracBits=0 dec", scaledToDecimalString(p2.scaled, 0, 6), "5");

      // hex pad and group
      eq("hex of 0xF pad", hexFromScaled(15n, 8, false), "0F");

      const pass = tests.filter(t=>t[0]).length;
      const fail = tests.filter(t=>!t[0]);
      console.group("[SelfTests] single-file qtool");
      console.log(`Passed: ${pass}/${tests.length}`);
      fail.forEach(([ok,name,a,b])=>console.warn("FAIL:", name, "got:", a, "expected:", b));
      console.groupEnd();
    }
  </script>
</body>
</html>
